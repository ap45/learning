################ NEW LOGIC #################

@Service
public class UserService {
    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public List<User> searchUsers(List<SearchCriteria> searchCriteriaList) {
        return userRepository.findAll((root, query, criteriaBuilder) -> {
            List<Predicate> predicates = new ArrayList<>();

            for (SearchCriteria criteria : searchCriteriaList) {
                String queryKey = criteria.getQueryKey();
                QueryOperation queryOperation = criteria.getQueryOperation();
                Object queryValue = criteria.getQueryValue();

                if (queryValue instanceof String) {
                    String singleValue = (String) queryValue;
                    Expression<String> expression = root.get(queryKey).as(String.class);

                    switch (queryOperation) {
                        case EQUALS:
                            predicates.add(criteriaBuilder.equal(expression, singleValue));
                            break;
                        case NOT_EQUALS:
                            predicates.add(criteriaBuilder.notEqual(expression, singleValue));
                            break;
                        case CONTAINS:
                            predicates.add(criteriaBuilder.like(expression, "%" + singleValue + "%"));
                            break;
                        case NOT_CONTAINS:
                            predicates.add(criteriaBuilder.notLike(expression, "%" + singleValue + "%"));
                            break;
                        default:
                            throw new IllegalArgumentException("Invalid query operation for query key " + queryKey + ": " + queryOperation);
                    }
                } else if (queryValue instanceof List) {
                    List<String> valueList = (List<String>) queryValue;
                    Expression<String> expression = root.get(queryKey).as(String.class);

                    List<Predicate> innerPredicates = new ArrayList<>();

                    for (String value : valueList) {
                        switch (queryOperation) {
                            case EQUALS:
                                innerPredicates.add(criteriaBuilder.equal(expression, value));
                                break;
                            case NOT_EQUALS:
                                innerPredicates.add(criteriaBuilder.notEqual(expression, value));
                                break;
                            case CONTAINS:
                                innerPredicates.add(criteriaBuilder.like(expression, "%" + value + "%"));
                                break;
                            case NOT_CONTAINS:
                                innerPredicates.add(criteriaBuilder.notLike(expression, "%" + value + "%"));
                                break;
                            default:
                                throw new IllegalArgumentException("Invalid query operation for query key " + queryKey + ": " + queryOperation);
                        }
                    }

                    predicates.add(criteriaBuilder.or(innerPredicates.toArray(new Predicate[0])));
                }
            }

            return criteriaBuilder.and(predicates.toArray(new Predicate[0]));
        });
    }
}





#in and not in operations#######
@Service
public class UserService {
    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public List<User> searchUsers(List<SearchCriteria> searchCriteriaList) {
        return userRepository.findAll((root, query, criteriaBuilder) -> {
            List<Predicate> predicates = new ArrayList<>();

            for (SearchCriteria criteria : searchCriteriaList) {
                String queryKey = criteria.getQueryKey();
                QueryOperation queryOperation = criteria.getQueryOperation();
                Object queryValue = criteria.getQueryValue();

                if (queryValue instanceof String) {
                    String singleValue = (String) queryValue;
                    Expression<String> expression = root.get(queryKey).as(String.class);

                    switch (queryOperation) {
                        case EQUALS:
                            predicates.add(criteriaBuilder.equal(expression, singleValue));
                            break;
                        case NOT_EQUALS:
                            predicates.add(criteriaBuilder.notEqual(expression, singleValue));
                            break;
                        case CONTAINS:
                            predicates.add(criteriaBuilder.like(expression, "%" + singleValue + "%"));
                            break;
                        case NOT_CONTAINS:
                            predicates.add(criteriaBuilder.notLike(expression, "%" + singleValue + "%"));
                            break;
                        default:
                            throw new IllegalArgumentException("Invalid query operation for query key " + queryKey + ": " + queryOperation);
                    }
                } else if (queryValue instanceof List) {
                    List<String> valueList = (List<String>) queryValue;
                    Expression<String> expression = root.get(queryKey).as(String.class);

                    switch (queryOperation) {
                        case IN:
                            predicates.add(expression.in(valueList));
                            break;
                        case NOT_IN:
                            predicates.add(criteriaBuilder.not(expression.in(valueList)));
                            break;
                        default:
                            for (String value : valueList) {
                                switch (queryOperation) {
                                    case EQUALS:
                                        predicates.add(criteriaBuilder.equal(expression, value));
                                        break;
                                    case NOT_EQUALS:
                                        predicates.add(criteriaBuilder.notEqual(expression, value));
                                        break;
                                    case CONTAINS:
                                        predicates.add(criteriaBuilder.like(expression, "%" + value + "%"));
                                        break;
                                    case NOT_CONTAINS:
                                        predicates.add(criteriaBuilder.notLike(expression, "%" + value + "%"));
                                        break;
                                    default:
                                        throw new IllegalArgumentException("Invalid query operation for query key " + queryKey + ": " + queryOperation);
                                }
                            }
                    }
                } else if (queryValue instanceof Date) {
                    Date dateValue = (Date) queryValue;
                    Expression<Date> expression = root.get(queryKey).as(Date.class);

                    switch (queryOperation) {
                        case EQUALS:
                            predicates.add(criteriaBuilder.equal(expression, dateValue));
                            break;
                        case NOT_EQUALS:
                            predicates.add(criteriaBuilder.notEqual(expression, dateValue));
                            break;
                        default:
                            throw new IllegalArgumentException("Invalid query operation for query key " + queryKey + ": " + queryOperation);
                    }
                }
            }

            return criteriaBuilder.and(predicates.toArray(new Predicate[0]));
        });
    }
}




##3rd logic #####
@Service
public class UserService {
    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public List<User> searchUsers(List<SearchCriteria> searchCriteriaList) {
        return userRepository.findAll((root, query, criteriaBuilder) -> {
            List<Predicate> predicates = new ArrayList<>();

            for (SearchCriteria criteria : searchCriteriaList) {
                String queryKey = criteria.getQueryKey().toLowerCase();
                QueryOperation queryOperation = criteria.getQueryOperation();
                Object queryValue = criteria.getQueryValue();

                Expression<String> expression = root.get(queryKey).as(String.class);
                Predicate predicate;

                switch (queryOperation) {
                    case EQUALS:
                        predicate = buildEqualsPredicate(criteriaBuilder, expression, queryValue);
                        break;
                    case NOT_EQUALS:
                        predicate = buildNotEqualsPredicate(criteriaBuilder, expression, queryValue);
                        break;
                    case IN:
                        predicate = buildInPredicate(criteriaBuilder, expression, queryValue);
                        break;
                    case NOT_IN:
                        predicate = buildNotInPredicate(criteriaBuilder, expression, queryValue);
                        break;
                    case CONTAINS:
                        predicate = buildContainsPredicate(criteriaBuilder, expression, queryValue);
                        break;
                    case NOT_CONTAINS:
                        predicate = buildNotContainsPredicate(criteriaBuilder, expression, queryValue);
                        break;
                    default:
                        throw new IllegalArgumentException("Invalid query operation for query key " + queryKey + ": " + queryOperation);
                }

                predicates.add(predicate);
            }

            return criteriaBuilder.and(predicates.toArray(new Predicate[0]));
        });
    }

    private Predicate buildEqualsPredicate(CriteriaBuilder criteriaBuilder, Expression<String> expression, Object queryValue) {
        if (queryValue instanceof List) {
            List<String> values = convertValuesToLowerCase((List<String>) queryValue);
            return expression.in(values);
        } else {
            return criteriaBuilder.equal(expression, convertValueToLowerCase(queryValue));
        }
    }

    private Predicate buildNotEqualsPredicate(CriteriaBuilder criteriaBuilder, Expression<String> expression, Object queryValue) {
        if (queryValue instanceof List) {
            List<String> values = convertValuesToLowerCase((List<String>) queryValue);
            return criteriaBuilder.not(expression.in(values));
        } else {
            return criteriaBuilder.notEqual(expression, convertValueToLowerCase(queryValue));
        }
    }

    private Predicate buildInPredicate(CriteriaBuilder criteriaBuilder, Expression<String> expression, Object queryValue) {
        if (queryValue instanceof List) {
            List<String> values = convertValuesToLowerCase((List<String>) queryValue);
            return criteriaBuilder.isTrue(criteriaBuilder.function("member", Boolean.class, expression, criteriaBuilder.literal(values)));
        } else {
            return criteriaBuilder.equal(expression, convertValueToLowerCase(queryValue));
        }
    }

    private Predicate buildNotInPredicate(CriteriaBuilder criteriaBuilder, Expression<String> expression, Object queryValue) {
        if (queryValue instanceof List) {
            List<String> values = convertValuesToLowerCase((List<String>) queryValue);
            return criteriaBuilder.isFalse(criteriaBuilder.function("member", Boolean.class, expression, criteriaBuilder.literal(values)));
        } else {
            return criteriaBuilder.notEqual(expression, convertValueToLowerCase(queryValue));
        }
    }

    private Predicate buildContainsPredicate(CriteriaBuilder criteriaBuilder, Expression<String> expression, Object queryValue) {
        String value = convertValueToLowerCase(queryValue);
        return criteriaBuilder.like(expression, "%" + value + "%");
    }

    private Predicate buildNotContainsPredicate(CriteriaBuilder criteriaBuilder, Expression<String> expression, Object queryValue) {
        String value = convertValueToLowerCase(queryValue);
        return criteriaBuilder.notLike(expression, "%" + value + "%");
    }

    private String convertValueToLowerCase(Object value) {
        if (value instanceof String) {
            return ((String) value).toLowerCase();
        }
        return value.toString();
    }

    private List<String> convertValuesToLowerCase(List<String> values) {
        return values.stream()
                .map(String::toLowerCase)
                .collect(Collectors.toList());
    }
}
